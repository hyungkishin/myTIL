### 자동 구성 기반 어플리케이션

### @AutoConfiguration 이 어떻게 만들어 졌고 어떻게 동작하는지 
- 이미 Spring 에 다 있는 기술을 Spring Boot 가 잘 사용할수 있게 도와주는것이다.
- 이것을 잘 이해하려면 Spring Boot 가 어노테이션을 활용할때 사용하는 몇가지 기법을 잘 이해해야 한다.
  - 그리고 나서 응용이다.

### 첫번째.
- meta Annotation 을 이해하자.
- 그림으로 보면 아래와 같다.

![](images/8c6760e7.png)

### 잠깐 메타에너테이션 ?
- 메타 에너테이션은 메타 어노테이션은 어노테이션에 붙이는 어노테이션이다. 
- 즉, 사용할 어노테이션을 정의하는 데 사용한다. 
- 메타 어노테이션은 사용할 어노테이션의 적용대상 또는 어노테이션을 유지하는 시간 등을 규정한다.
- 그래서 그게 어떻게 생겼더라 ? 

![](images/184d358b.png)

### 그래서 메타 어노테이션을 사용하면 뭐가 좋나요
- 적용해서 기능적인 면에선 차이가 없다.
- 그러나 많다면 많고 적다면 적은 장점중에 몇가지를 꼽자면,
  1. 코드 재사용성
  2. 일관성과 표준화
  3. 개선된 가독성
  4. 유지보수 용이성 ( 개선된 협업 )
  5. 복답한 동작의 캡슐화 가 있다.

### 일관성과 표준화
- 컴포넌트를 직접 붙이는것과 메타 어노테이션을 붙이는것은 "역할에 인지" + "추가적인 정보를 얻을 수 있다" 라는 차이가 있다.
- 아 이거는 Web Mvc 에 Controller 역할을 하는구나, 이거는 비즈니스 로직을 담당하는 Service 로구나. 라는 추가적인 정보를 얻을 수 있다.

### 좀더 자세히 (확장)
- 메타 어노테이션에는 없었던 엘리먼트를 추가함에 따라, 새로운 기능을 확장 할 수 있다.
  - 에노테이션 을 상속이라고 생각하면 안된다. 에너테이션 자체에는 상속이라는 개념이 없다.
  - interface 처럼 다른 interface 를 extends 한다고 보면 안된다.
  - 그냥 어노테이션을 정의할때, 다른 어노테이션을 붙이는것이다. 라고 얘기하면 너무 아쉬운 대답이고, ( 그냥 대답하지도 말아야한다 이렇게 말할꺼면 )
  - 메타 어노테이션엔 가장 중요하게 따라붙는 필연적인 Target 과 Retention 이라는 정보를 꼭 주어야 하는데, 
  - 타깃이 중요한 이유는 에노테이션 이 적용될 수 있는 위치가 굉장히 많은데, 그중에서 에노테이션 타입의 위치에 있어야지만 메타어노테이션이 될 수 있다.

### 피부에 와닿는 예제로
- 일상생활 에서 제일 많이 사용하고 있는 Junit 의 @Test 라는 어노테이션을 보자.

![](images/38457795.png)
![](images/b0238f2b.png)

- 이름이 굳이 @Test 여야 하냐면 아니고, 만들면된다.

### 한번, 만들어보자
```text

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD) // 테스트 어노테이션은 method 에 붙으니까 method 로 .
@Test
@interface 형기_Test {

}
```

### 직관적으로 봤을때 아래 어노테이션은 빠른 유닛테스트 구나 라는것을 유추할수 있게 도와준다.
![](images/76221a2a.png)

### 그래서 어떻게 동작하나요 ?
- junit 의 @Test 는 어떻게 동작하나요 ? 를 먼져 알아야한다.
- junit 이 @Test 라는 어노테이션을 찾아서 아 얘는 테스트 메소드구나 라고 인지하고, 테스트 메소드를 실행한다.
- 리플렉션을 이용한 방법으로 동작한다.

### 함성 어노테이션
- 메타 어노테이션을 하나 이상을 적용해서 만드는 Composite 어노테이션을 말한다.
- 그림으로 보면 아래 @RestController 와 같은것이다.

![](images/7554ad95.png)